c
active
OauthAccessToken.first.expires_in
token.expires_in
token
token.token_type
token.expires_in? 3
OauthAccessToken.first.expires_in?
token.expires_in?
token.expired?
token.user
token.methods
token = OauthAccessToken.find_by_token(params[:token])
token.methods
user = User.find(OauthAccessToken.find_by_token(params[:token]).resource_owner_id)
OauthAccessToken.find_by_token(params[:token]).resource_owner_id
OauthAccessToken.find_by_token(params[:token]).user
OauthAccessToken.find_by_token(params[:token])
c
OauthAccessToken.find_by_token(params[:token])
OauthAccessToken
c
doorkeeper_token
OauthAccessToken
params[:token]
c
params
c
current_user
c
params
c
params
c
ni.image.blob
c.logo.blob
c.logo.filename
ni.image.filename
ni.image.attached?
ni.image
c.logo.variant(resize: '100x100')
c.logo.variant
c.logo
c = Company.find_by_name "enjo"
Company.find_by_name "enjo"
Company.last
Company.first
ni.image
ni.image.methods
ni.image.record.variant
ni.image.record
ni.image.url
ni.image.uri
url_for(ni.image)
ni.image
ni.image.variant
ni.image.attached?
n
ni.image.attached?
ni.image.variant
n
ni.image.attached?
quit
stop
out
up
c
record.roles.map {|role| role.name.capitalize }.join(', ')
record.roles.map {|role| role.name }.join(', ')
record.roles.map {|role| role.name }
record.roles.map {|role| role.label }
record.roles
c
device.id
quit
matches[1]
matches[0]
matches
matches = e.message.match '"(.*)" is not a registered'
e.message.match '"(.*)" is not a registered'
e.message
e
c
e
messages
c
params[:deviceType]
params
c
attributes[:device_type].present?
attributes
c
user
fc
c
subscription_user.first.subscription_user_news_types
subscription_user.subscription_user_news_types
sunt.subscription_user
sunt = SubscriptionUserNewsType.first
SubscriptionUserNewsType.first
SubscriptionUserNewsType.firest
SubscriptionUserNewsType
subscription_user.subscription_user_news_type
subscription_user.subscription_user_news_types
subscription_user
n
user
c
rails_blob_path(news_item.image)
rails_blob_url(news_item.image)
news_item.image.path
news_item.image.url
url_for(news_item.image)
news_item.image.attached?
news_item.image
c
news_item.image.path(:medium)
news_item.image.url(:medium)
news_item.image.path
news_item.image.url
c
Settings.google.api_key
Settings.google
Settings
ENV.fetch('AWS_ACCESS_KEY_ID')
ENV['AWS_ACCESS_KEY_ID']
Rails.application.config.paperclip_defaults
c
Rails.application.config.paperclip_defaults
c
Aws.config.update({region: ENV.fetch('AWS_REGION'), credentials: Aws::Credentials.new(ENV.fetch('AWS_ACCESS_KEY_ID'), ENV.fetch('AWS_SECRET_ACCESS_KEY'))})
Aws.config.update({region: ENV.fetch('AWS_REGION'), credentials: Aws::Credentials.new(ENV.fetch('AWS_ACCESS_KEY_ID'), ENV.fetch('AWS_SECRET_ACCESS_KEY')})
Aws.config.update({region: ENV.fetch('AWS_REGION')})
Aws.config.update({
Aws.config.to_json
Aws.config.methods
Aws.config
Aws::Rails.credentials
Aws::Rails.methods
Aws::Rails
Rails.application.config.paperclip_defaults
Rails.application.config
Config.get
Config
config
c
ENV.fetch('AWS_ACCESS_KEY_ID')
ENV
c
exception
n
params[:photo]
continue
news_item.image.url
news_item.image.uri
news_item.image.path
news_item.image
continue
params[:news_item_id]
params
continue
params[:photo]
params
continue
params
continue
params
continue
n
params[:photo].path
params[:photo].size
params[:photo]
params
c
params
c
doorkeeper_token
current_resource_owner
user
n
user
c
Doorkeeper::OAuth::TokenResponse.new(access_token).body["access_token"].to_json
Doorkeeper::OAuth::TokenResponse.new(access_token).body["access_token"]
Doorkeeper::OAuth::TokenResponse.new(access_token).body.access_token
Doorkeeper::OAuth::TokenResponse.new(access_token).body
{ access_token: Doorkeeper::OAuth::TokenResponse.new(access_token).body.to_json }
{ access_token: Doorkeeper::OAuth::TokenResponse.new(access_token).body.to_json }.
c
news_items.first.first
news_items.first
news_items
c
pp user.news_types_by_company
user.news_types_by_company
n
params
c
pp hash
hash
c
final_companies.sort_by { |c| c[:enabled] ? 0 : 1 }
final_companies.first[:enabled] === false
final_companies.first[:enabled]
final_companies.sort_by { |c| c[:enabled] }
final_companies.sort_by { |c| c.enabled }
sorted_companies = final_companies.
final_companies.sort_by
final_companies.order_by
final_companies.order
pp user_companies
pp final_companies
pp
final_companies
c
doorkeeper_token
doorkeep_token
current_resource_owner
c
doorkeeper_token
c
doorkeeper_token
c
doorkeeper_token
c
up
n
up
n
step
User.find(1)
doorkeeper_token.resource_owner_id
doorkeeper_token
c
params["firstName"]
params[:firstName]
params
c
u.access_tokens.last.token == params[:access_token]
u.access_tokens.last.token == params[:access_tokens]
u.access_tokens.last.token
u.access_tokens.last
u.access_tokens
u = User.first
params
current_user
c
User.first
current_user
params
c
params
params[:access_token]
c
final_companies
c
